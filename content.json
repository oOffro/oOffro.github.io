{"meta":{"title":"奔跑的蜗牛","subtitle":"一天进步一点","description":null,"author":"远方","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-07-30T07:36:32.100Z","updated":"2017-07-30T07:36:32.100Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-07-29T16:32:03.000Z","updated":"2017-07-30T07:36:56.676Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"微信公众号开发工具类","slug":"微信公众号开发工具类","date":"2017-07-31T09:53:42.000Z","updated":"2017-07-31T12:50:53.268Z","comments":true,"path":"2017/07/31/微信公众号开发工具类/","link":"","permalink":"http://yoursite.com/2017/07/31/微信公众号开发工具类/","excerpt":"微信公众号开发过程中需要用到的工具类，以及所需要的相关方法。微信公众号开发中的重要拦截器–&gt;微信网页授权","text":"微信公众号开发过程中需要用到的工具类，以及所需要的相关方法。微信公众号开发中的重要拦截器–&gt;微信网页授权 sha1加密–&gt;SecurityUtil作用用于将微信服务器传来的token，timestamp，nonce组成的数组，经过字典排序后，执行sha1加密。返回结果与传来的signature比较，相等则返回echostr。 字典排序12String[] arr = &#123; token, timestamp, nonce &#125;;Arrays.sort(arr); 加密工具类123456789101112131415161718192021//对str进行sha1的加密public class SecurityUtil &#123; public static String sha1(String str) &#123; try &#123; StringBuilder sb = new StringBuilder(); MessageDigest digest = MessageDigest.getInstance(\"sha1\"); // 放入加密字符串 digest.update(str.getBytes()); // 进行加密 byte[] digestMsg = digest.digest(); // byte转换16进制 for (byte b : digestMsg) &#123; sb.append(String.format(\"%02x\", b)); &#125; return sb.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return str; &#125;&#125; 解析xml作用将微信服务器中传来的xml格式的文件解析为字符串，获取它的值 工具类代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class XmlPullParserUtil &#123; /** * 参数: InputStream,Reader 为了兼容测试,使用Reader * 返回值: * 方案1:解析为一个java对象,抽取一个基础类BaseMsg,里面包含所有消息的公共属性,为每一种消息再定制一个子类, * 让它继承与BaseMsg并且扩展自己属性(TextMsg,ImgMsg....)--&gt;需要大量的domain,不采用 * 方案2:直接返回一个Map,可以表示任何消息,消息的key不一致罢了.(采纳) * * @return */ public static Map&lt;String, String&gt; parse(Reader reader) &#123; Map&lt;String, String&gt; result = new HashMap&lt;&gt;(); try &#123; //1)获取xmlpull解析器 XmlPullParser xmlPullParser = XmlPullParserFactory.newInstance().newPullParser(); //2)设置解析内容 xmlPullParser.setInput(reader); //3)进行解析 //xmlpull常用事件 //XmlPullParser.START_DOCUMENT 文档开始 //XmlPullParser.START_TAG 标签开始 //XmlPullParser.END_DOCUMENT 文档结束 //XmlPullParser.END_TAG 标签结束 //xmlpull当前事件状态 int eventType = xmlPullParser.getEventType(); //一直解析直到文档结束,意味着解析完毕 while (eventType != XmlPullParser.END_DOCUMENT) &#123; //解析时机,就是标签开始并且标签名不为xml String tagName = xmlPullParser.getName(); if (eventType == XmlPullParser.START_TAG &amp;&amp; !\"xml\".equals(tagName)) &#123; String tagContent = xmlPullParser.nextText(); result.put(tagName, tagContent); &#125; //解析完当前事件后,需要改变当前事件为下一个事件 eventType = xmlPullParser.next(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return result; &#125;&#125; HttpClientUtilAccessToken作用使用GET_ACCESSTOKEN_URL 以及测试号中的两个唯一的参数值APPID和APPSECRET作为url，获取ACCESS_TOKENACCESS_TOKEN用于给微信添加各种各样的功能。 代码123456789101112131415161718@Testpublic void testAccessToken() throws Exception &#123; String url = WeixinConstants.GET_ACCESSTOKEN_URL.replace(\"APPID\", WeixinConstants.APPID).replace(\"APPSECRET\", WeixinConstants.APPSECRET); // 1 创建httpClient执行对象 HttpClient execution = new DefaultHttpClient(); // 2 创建httpGet请求 HttpGet httpGet = new HttpGet(url); // 3 通过执行对象传入执行请求,发送请求,获取响应对象 HttpResponse response = execution.execute(httpGet); // 4打印状态码,用于排错 System.out.println(\"statusCode:\" + response.getStatusLine().getStatusCode()); // 4 通过响应对象获取响应实体,把响应实体转换json字符串 HttpEntity responseEntity = response.getEntity(); String jsonStr = EntityUtils.toString(responseEntity); System.out.println(jsonStr);&#125; httpGet作用代码123456789101112131415161718public static String httpGet(String url) &#123; try &#123; // 1.创建一个http执行器 HttpClient client = new DefaultHttpClient(); // 2.创建一个http的get请求 HttpGet get = new HttpGet(url); // 3.在执行器中执行httpget请求,并拿到响应对象 HttpResponse response = client.execute(get); // 4.打印状态码,用于排错 System.out.println(response.getStatusLine().getStatusCode()); // 5.entity里面封装了响应的内容,只需转为字符串即可 HttpEntity entity = response.getEntity(); return EntityUtils.toString(entity); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; httpPost作用代码1234567891011121314151617181920public static String httpPost(String url,String jsonParam) &#123; try &#123; // 1.创建一个http执行器 HttpClient client = new DefaultHttpClient(); // 2.创建一个http的post请求 HttpPost post = new HttpPost(url); // 3.设置httppost的请求的参数 post.setEntity(new StringEntity(jsonParam, \"utf-8\")); // 4.在执行器中执行httpPost请求,拿到响应对象 HttpResponse response = client.execute(post); // 5.打印状态码,用于排错 System.out.println(response.getStatusLine().getStatusCode()); // 6.entity里面封装了响应的内容,只需转为字符串即可 HttpEntity entity = response.getEntity(); return EntityUtils.toString(entity); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 微信网页授权(拦截器)作用用于微信网页授权登录,获取当前微信用户。在企业级开发中，将微信账户和企业的账户进行绑定，可以直接使用微信浏览企业的系统。 前提需要设置微信公众号中–&gt;授权回调域名(第一层域名)位置：微信公众号测试账号–&gt;网页服务–&gt;网页账号–&gt;修改打上@WebFilter注解,/*表示拦截所有请求1@WebFilter(\"/*\") 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243@Overridepublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest hRequest = (HttpServletRequest) request; HttpServletResponse hResponse = (HttpServletResponse) response; // 如果session中已经存在微信号了，就不用获取了，否则要获取，获取到以后要存放sesion String fromUserName = (String) hRequest.getSession().getAttribute(\"fromUserName\"); if (fromUserName == null) &#123; // 只有在微信端才做里面的操作 String agent = hRequest.getHeader(\"User-Agent\"); if (agent != null &amp;&amp; agent.toLowerCase().indexOf(\"micromessenger\") &gt;= 0) &#123; String code = request.getParameter(\"code\"); String state = request.getParameter(\"state\"); // 如果code不为空，scope为base,scope为userInfo代表用户已经同意,只需发送openid的请求来获取openid if (code != null &amp;&amp; state != null &amp;&amp; state.equals(\"1\")) &#123; System.out.println(\"1111111111111\"); // 通过Code获取openid来进行授权 String url = WeixinConstants.AUTH_GET_OID.replace(\"APPID\", WeixinConstants.APPID) .replace(\"SECRET\", WeixinConstants.APPSECRET).replace(\"CODE\", code); String json = HttpClientUtil.httpGet(url); String openid = JSONObject.parseObject(json).getString(\"openid\"); hRequest.getSession().setAttribute(\"fromUserName\", openid); System.out.println(openid + \"33333333333\"); &#125; else &#123; System.out.println(\"2222222222222222\"); // 发送用户同意的请求 String path = hRequest.getRequestURL().toString(); String query = hRequest.getQueryString(); if (query != null) &#123; path = path + \"?\" + query; &#125; System.out.println(path); String uri = WeixinConstants.AUTH_URL.replace(\"APPID\", WeixinConstants.APPID) .replace(\"REDIRECT_URI\", URLEncoder.encode(path, \"UTF-8\")) .replace(\"SCOPE\", \"snsapi_userinfo\").replace(\"STATE\", \"1\"); hResponse.sendRedirect(uri); return; &#125; &#125;&#125;chain.doFilter(hRequest, hResponse);&#125;","categories":[{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/categories/工具类/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"},{"name":"工具类","slug":"工具类","permalink":"http://yoursite.com/tags/工具类/"}]},{"title":"微信公众号入门笔记(二)","slug":"微信公众号学习笔记(二)","date":"2017-07-31T01:10:41.000Z","updated":"2017-07-31T13:24:37.444Z","comments":true,"path":"2017/07/31/微信公众号学习笔记(二)/","link":"","permalink":"http://yoursite.com/2017/07/31/微信公众号学习笔记(二)/","excerpt":"在学习微信公众号中一些值得注意的点。微信公众平台技术文档自定义菜单与绑定用户","text":"在学习微信公众号中一些值得注意的点。微信公众平台技术文档自定义菜单与绑定用户 自定义菜单菜单的限制1、自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。2、一级菜单最多4个汉字，二级菜单最多7个汉字，多出来的部分将会以“…”代替。 菜单的类型(type)1、click：点击推事件用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；2、view：跳转URL用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。 fastJson简介 Fastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。 使用有两个核心类,一个对象–&gt;JSONObject , 一个数组–&gt;JSONArray JSONObject是一个Map，用做菜单的对象，包括根对象，一级菜单对象，二级菜单对象。根对象作为按钮，装入一级菜单容器1root.put(\"button\", oneLevelMenus); 一级菜单对象，作为子按钮，装二级菜单容器12function.put(\"sub_button\", functionTwoLevelMenus);business.put(\"sub_button\", businessTwoLeverMenus); JSONArray1.一个容器，一级菜单容器用来装一级菜单对象，二级菜单容器装二级菜单对象。2.一级菜单对象中装二级菜单容器，根对象装一级菜单容器","categories":[{"name":"微信","slug":"微信","permalink":"http://yoursite.com/categories/微信/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"}]},{"title":"微信公众号入门笔记(一)","slug":"学习笔记","date":"2017-07-29T16:04:46.000Z","updated":"2017-07-31T13:10:48.667Z","comments":true,"path":"2017/07/30/学习笔记/","link":"","permalink":"http://yoursite.com/2017/07/30/学习笔记/","excerpt":"在学习微信公众号中一些值得注意的点。微信公众平台技术文档环境搭建与消息的接收和回复","text":"在学习微信公众号中一些值得注意的点。微信公众平台技术文档环境搭建与消息的接收和回复 开发环境搭建引入微信服务器转发请求给用户服务器，就需要接入认证。首先需要将本地服务器映射到外网。需要使用映射软件。常见的映射软件有:花生壳，nat123。这里采用的是花生壳 配置外网映射配置十分简单，注意内网与外网的端口，均选择80 测试号接入采用密文认证的方式 123456789101112131415161718192021222324252627282930@Controller@RequestMapping(\"/index\")public class IndexController &#123; @RequestMapping(method = RequestMethod.GET) public void signature(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // 接收4个参数 String token = \"weixin\"; String signature = request.getParameter(\"signature\"); String timestamp = request.getParamete(\"timestamp\"); String nonce = request.getParameter(\"nonce\"); String echostr = request.getParameter(\"echostr\"); // 1）将token、timestamp、nonce三个参数进行字典(数组)序排序 String[] arr = &#123; token, timestamp, nonce &#125;; // 2）将三个参数字符串拼接成一个字符串进行sha1加密 StringBuilder sb = new StringBuilder(); for (String param : arr) &#123; sb.append(param); &#125; String content = sb.toString(); // sha1加密 String security = SecurityUtil.sha1(content); // 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 if (security.equals(signature)) &#123; response.getWriter().println(echostr); &#125; else &#123; // 认证失败 throw new RuntimeException(\"认证失败!\"); &#125; &#125;&#125; sha1加密 微信公众号测试号接口配置信息URL：为外网映射的地址+Controller中的映射地址。如：http://offieo.6655.la/indexToken：自己填写，这里是“weixin” 注意点：1 明文模式，是直接回传Token的值，但是在密文模式，需要根据认证的结果保存参数来作为加解密的依据。1response.getWriter().println(Token); 2 如果改变了地址，需要重新认证。3 认证地址必须以http开头，并且端口是80","categories":[{"name":"微信","slug":"微信","permalink":"http://yoursite.com/categories/微信/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-07-29T08:10:20.126Z","updated":"2017-07-30T17:48:06.186Z","comments":true,"path":"2017/07/29/hello-world/","link":"","permalink":"http://yoursite.com/2017/07/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}